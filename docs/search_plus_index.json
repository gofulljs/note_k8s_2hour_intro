{"./":{"url":"./","title":"Kubernetes 课程导读","keywords":"","body":"k8s 课程导读 a note use gitbook for Kubernetes 二小时入门教程, 根据自己的学习会做一些添加和补充 B 站视频地址 https://www.bilibili.com/video/BV1k24y197KC 原文档地址 https://www.yuque.com/wukong-zorrm/qdoy5p 为什么 Kubernetes 学起来很难？ zh Kubernetes 本身比较复杂，组件众多，安装过程比较麻烦 本课程使用 K3s 快速创建学习环境，不要把时间和精力浪费在搭环境上 网络问题，许多谷歌镜像或软件仓库访问不到，拉取失败 配置阿里云镜像加速 手动拉取镜像、手动导出、导入镜像 Kubernetes 版本有重大变化，网上好多教程已过时 kubernetes 从 1.24 版本开始，移除了对 docker 的支持 本课程采用 1.25 版本，使用 containerd 作为容器运行时 课程中对 containerd 用法以及可能遇到的问题进行了说明 官方文档有错误，许多例子或命令运行不起来 本课程会帮你避过官方文档中的坑 很多教程只有例子，没有实战，导致“一学就会，一用就废” 本课程会演示常用中间件的安装（MySQL 主从集群、Redis 主从集群） 本课程会演示如何在 K8s 上运行一个完整的应用 应用程序包括前端(node/nginx)、缓存(redis)、数据库(mysql)、后端(java） "},"base/":{"url":"base/","title":"Kubernetes 基础","keywords":"","body":""},"base/intro.html":{"url":"base/intro.html","title":"Kubernetes 简介","keywords":"","body":"Kubernetes 简介 简介 Kubernetes 是一个开源的容器编排引擎和容器集群管理工具，用来对容器化应用进行自动化部署、 扩缩和管理。 Kubernetes 这个名字源于希腊语，意为“舵手”或“飞行员”。k8s 这个缩写是因为 k 和 s 之间有 8 个字符。 Google 在 2014 年开源了 Kubernetes 项目。 优势 Kubernetes 建立在 Google 大规模运行生产工作负载十几年经验的基础上， 结合了社区中最优秀的想法和实践。它之所以能够迅速流行起来，是因为它的许多功能高度契合互联网大厂的部署和运维需求。 Kubernetes 可以提供： 服务发现和负载均衡 Kubernetes 可以使用 DNS 名称或自己的 IP 地址来曝露容器。 如果进入容器的流量很大 Kubernetes 可以负载均衡并分配网络流量，从而使部署稳定。 存储编排 Kubernetes 允许你自动挂载你选择的存储系统，例如本地存储、公共云提供商等。 自动部署和回滚 你可以使用 Kubernetes 描述已部署容器的所需状态， 它可以以受控的速率将实际状态更改为期望状态。 例如，你可以自动化 Kubernetes 来为你的部署创建新容器， 删除现有容器并将它们的所有资源用于新容器。也可以是方便的实现金丝雀部署(canary deployment )。 自动完成装箱计算 你为 Kubernetes 提供许多节点组成的集群，在这个集群上运行容器化的任务。 你告诉 Kubernetes 每个容器需要多少 CPU 和内存 (RAM)。 Kubernetes 可以将这些容器按实际情况调度到你的节点上，以最佳方式利用你的资源。 自我修复 Kubernetes 将重新启动失败的容器、替换容器、杀死不响应用户定义的运行状况检查的容器， 并且在准备好服务之前不将其通告给客户端。 密钥与配置管理 ubernetes 允许你存储和管理敏感信息，例如密码、OAuth 令牌和 ssh 密钥。 你可以在不重建容器镜像的情况下部署和更新密钥和应用程序配置，也无需在堆栈配置中暴露密钥。 云原生 2015 年由 Google、Redhat 等大型云计算厂商以及一些开源公司共同牵头成立了 Cloud Native Computing Foundation（云原生计算基金会）。 云原生计算基金会（CNCF）致力于培育和维护一个厂商中立的开源生态系统，来推广云原生技术。 云原生的概念从此广泛传播。 云原生定义 Kubernetes 是 CNCF 托管的第一个开源项目。因此现在提到云原生，往往我们都把它与 kubernetes 联系起来。 通俗解释 使用 Java、Go、PHP、Python 等语言开发的应用我们称之为原生应用，在设计和开发这些应用时，使他们能够运行在云基础设施(或 kubernetes)上，从而使应用具备可弹性扩展的能力，我们称之为云原生应用。我们可以将云原生理解为以容器技术为载体、基于微服务架构思想的一套技术体系和方法论。 官方定义 云原生技术有利于各组织在公有云、私有云和混合云等新型动态环境中，构建和运行可弹性扩展的应用。云原生的代表技术包括容器、服务网格、微服务、不可变基础设施和声明式API。 这些技术能够构建容错性好、易于管理和便于观察的松耦合系统。结合可靠的自动化手段，云原生技术使工程师能够轻松地对系统作出频繁和可预测的重大变更。 微服务 在 Kubernetes 之前，Pivotal（开源 Java 开发框架 Spring 的母公司，后被 VMware 收购）是云原生应用的提出者，并推出了 Pivotal Cloud Foundry 云原生应用平台和 Spring Cloud 开发框架，成为云原生应用架构中先驱者和探路者。Spring Cloud 通过微服务架构，使程序具备可拓展性和在分布式环境运行的能力。Spring Cloud 和 Kubernetes 有很多功能是重合的，例如： 服务注册和发现 API 网关 负载均衡 配置管理 但是 Spring Cloud 只能用于 Java 应用开发，而 kubernetes 是语言无关的，可以用于各种语言开发的应用。 文档参考:https://kubernetes.io/zh-cn/docs/concepts/overview/ https://github.com/cncf/toc/blob/main/DEFINITION.md "},"base/architecture.html":{"url":"base/architecture.html","title":"Kubernetes 架构","keywords":"","body":"kubernetes 架构 kubernetes 架构 一个 Kubernetes 集群至少包含一个控制平面(control plane)，以及一个或多个工作节点(worker node)。 控制平面(Control Plane) : 控制平面负责管理工作节点和维护集群状态。所有任务分配都来自于控制平面。 工作节点(Worker Node) : 工作节点负责执行由控制平面分配的请求任务,运行实际的应用和工作负载。 控制平面 控制平面组件会为集群做出全局决策，比如资源的调度、检测和响应集群事件。 kube-apiserver 如果需要与 Kubernetes 集群进行交互，就要通过 API。 apiserver是 Kubernetes 控制平面的前端，用于处理内部和外部请求。 kube-scheduler 集群状况是否良好？如果需要创建新的容器，要将它们放在哪里？这些是调度程序需要关注的问题。 scheduler调度程序会考虑容器集的资源需求（例如 CPU 或内存）以及集群的运行状况。随后，它会将容器集安排到适当的计算节点。 etcd etcd 是一个键值对数据库，用于存储配置数据和集群状态信息。 kube-controller-manager 控制器负责实际运行集群，controller-manager 控制器管理器则是将多个控制器功能合而为一，降低了程序的复杂性。 controller-manager 包含了这些控制器： 节点控制器（Node Controller）：负责在节点出现故障时进行通知和响应 任务控制器（Job Controller）：监测代表一次性任务的 Job 对象，然后创建 Pods 来运行这些任务直至完成 端点控制器（Endpoints Controller）：填充端点（Endpoints）对象（即加入 Service 与 Pod） 服务帐户和令牌控制器（Service Account & Token Controllers）：为新的命名空间创建默认帐户和 API 访问令牌 Node 组件 节点组件会在每个节点上运行，负责维护运行的 Pod 并提供 Kubernetes 运行环境。 kubelet kubelet 会在集群中每个节点（node）上运行。 它保证容器（containers）都运行在 Pod 中。 当控制平面需要在节点中执行某个操作时，kubelet 就会执行该操作。 kube-proxy kube-proxy 是集群中每个节点（node）上运行的网络代理，是实现 Kubernetes 服务（Service） 概念的一部分。 kube-proxy 维护节点网络规则和转发流量，实现从集群内部或外部的网络与 Pod 进行网络通信。 容器运行时（Container Runtime） 这个基础组件使 Kubernetes 能够有效运行容器。 它负责管理 Kubernetes 环境中容器的执行和生命周期。 Kubernetes 支持许多容器运行环境，例如 containerd、 docker 以及 Kubernetes CRI (容器运行环境接口) 的其他任何实现。 组件关系 cloud-controller-manager 控制平面还包含一个可选组件cloud-controller-manager。 云控制器管理器（Cloud Controller Manager）允许你将你的集群连接到云提供商的 API 之上， 并将与该云平台交互的组件同与你的集群交互的组件分离开来。 如果在自己的环境中运行 Kubernetes，或者在本地计算机中运行学习环境， 所部署的集群不需要有云控制器管理器。 参考资料：https://kubernetes.io/zh-cn/docs/concepts/overview/components/ https://www.redhat.com/zh/topics/containers/kubernetes-architecture "},"base/minikube.html":{"url":"base/minikube.html","title":"安装 Minikube","keywords":"","body":"安装 Minikube docker-desktop 新版本自带了 kubenetes, 不需要使用 minikube 了。 自带的安装较慢可以使用 https://github.com/AliyunContainerService/k8s-for-docker-desktop 去安装 kubenetes 和 dashboard dashbord https://github.com/kubernetes/dashboard 安装官方控制台 kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.7.0/aio/deploy/recommended.yaml 查看是否允许成功 $ kubectl get pods -A NAMESPACE NAME READY STATUS RESTARTS AGE kube-system coredns-5d78c9869d-tjhgv 1/1 Running 5 (7m45s ago) 2d22h kube-system coredns-5d78c9869d-vbzjn 1/1 Running 5 (7m45s ago) 2d22h kube-system etcd-docker-desktop 1/1 Running 5 (7m49s ago) 2d22h kube-system kube-apiserver-docker-desktop 1/1 Running 5 (7m40s ago) 2d22h kube-system kube-controller-manager-docker-desktop 1/1 Running 5 (7m50s ago) 2d22h kube-system kube-proxy-nrmkx 1/1 Running 5 (7m50s ago) 2d22h kube-system kube-scheduler-docker-desktop 1/1 Running 5 (7m50s ago) 2d22h kube-system storage-provisioner 1/1 Running 9 (6m28s ago) 2d22h kube-system vpnkit-controller 1/1 Running 5 (7m50s ago) 2d22h kubernetes-dashboard dashboard-metrics-scraper-5cb4f4bb9c-ws8sk 1/1 Running 1 (7m50s ago) 11m kubernetes-dashboard kubernetes-dashboard-6967859bff-5tvh6 1/1 Running 1 (7m50s ago) 11m 以上后 2 行出现代表成功 启用 dashboard kubectl proxy kubectl 会使得 Dashboard 可以通过 http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/ 访问。 UI 只能 通过执行这条命令的机器进行访问。 以上需要访问令牌 参考 https://github.com/AliyunContainerService/k8s-for-docker-desktop 部署访问令牌 授权 kube-system 默认服务账号 kubectl apply -f https://raw.githubusercontent.com/AliyunContainerService/k8s-for-docker-desktop/master/kube-system-default.yaml 获取 token windows $TOKEN=((kubectl -n kube-system describe secret default | Select-String \"token:\") -split \" +\")[1] kubectl config set-credentials docker-desktop --token=\"${TOKEN}\" echo $TOKEN or linux TOKEN=$(kubectl -n kube-system describe secret default| awk '$1==\"token:\"{print $2}') kubectl config set-credentials docker-desktop --token=\"${TOKEN}\" echo $TOKEN 生成好后在以下路径 powershell: %UserProfile%\\.kube\\config or sh: $HOME/.kube/config "},"base/env_k3s.html":{"url":"base/env_k3s.html","title":"使用 K3s 快速搭建集群","keywords":"","body":"使用 K3s 快速搭建集群 提示： 1.本课程基于kubernetes V1.25版本。提示： 2.从V1.24开始，kubernetes默认容器运行时使用containerd，不再使用docker。 为什么使用 K3s K3s 是一个轻量级的、$\\color{red}{完全兼容}$的 Kubernetes 发行版本。非常适合初学者。 K3s 将所有 Kubernetes 控制平面组件都封装在单个二进制文件和进程中，文件大小 提示： K3s完全兼容kubernetes，二者的操作是一样的，使用k3s完全满足我们学习kubernetes的要求，课程的最后，我们再使用kubeadm安装一个完整的集群。 离线安装 K3s 集群 K3s 集群分为 k3s Server(控制平面)和 k3s Agent(工作节点)。所有的组件都打包在单个二进制文件中。 运行环境 最低运行要求 内存: 512MB / CPU: 1 核心 K3s 版本：v1.25.0+k3s1 集群规划 主机名 IP 地址 配置 系统 网络 k8s-master 192.168.56.109 内存：2GCPU：2核硬盘：20G CentOS7.9.2009最小化安装 互联网:NAT网络内部网络: Host-only k8s-worker1 192.168.56.111 k8s-worker2 192.168.56.112 ps 每个主机需要设置 hostname k8s-master hostnamectl set-hostname k8s-master k8s-worker # k8s-worker1 hostnamectl set-hostname k8s-worker1 # k8s-worker2 hostnamectl set-hostname k8s-worker2 1.准备工作 需要在每台机器上执行如下命令： 关闭防火墙 设置 selinux(需要联网) systemctl disable firewalld --now yum install -y container-selinux selinux-policy-base yum install -y https://rpm.rancher.io/k3s/latest/common/centos/7/noarch/k3s-selinux-0.2-1.el7_8.noarch.rpm 2.下载安装包 下载安装脚本 install.sh：https://get.k3s.io/ 下载 k3s 二进制文件：k3s 下载必要的 image：离线安装需要的 image 文件 这些文件都可以在github仓库中获取：https://github.com/k3s-io/k3s 3.执行安装脚本 将k3s二进制文件移动到/usr/local/bin 目录，并添加执行权限 mv k3s /usr/local/bin chmod +x /usr/local/bin/k3s 将镜像移动到/var/lib/rancher/k3s/agent/images/目录（无需解压） mkdir -p /var/lib/rancher/k3s/agent/images/ cp ./k3s-airgap-images-amd64.tar.gz /var/lib/rancher/k3s/agent/images/ 在k8s-master节点执行： #修改权限 chmod +x install.sh #离线安装 INSTALL_K3S_SKIP_DOWNLOAD=true ./install.sh #安装完成后，查看节点状态 kubectl get node #查看token cat /var/lib/rancher/k3s/server/node-token #K10c4b79481685b50e4bca2513078f4e83b62d1d0b5f133a8a668b65c8f9249c53e::server:bf7b63be7f3471838cbafa12c1a1964d 在k8s-worker1和k8s-worker2节点执行 INSTALL_K3S_SKIP_DOWNLOAD=true \\ K3S_URL=https://192.168.56.109:6443 \\ K3S_TOKEN=K1012bdc3ffe7a5d89ecb125e56c38f9fe84a9f9aed6db605f7698fa744f2f2f12f::server:fdf33f4921dd607cadf2ae3c8eaf6ad9 \\ ./install.sh 排查错误 如果安装或启动不成功，可能有以下几个原因： 1. 时间不统一 2. IP有冲突，请为每个主机分配不同的IP 3. 主机名(hostname)重复，请为每个主机设置不同的主机名 4. 网卡的MAC有冲突，复制虚拟机时，请为所有网卡重新生产MAC地址 参考文档： https://k3s.io/ https://rancher.com/docs/k3s/latest/en/ https://rancher.com/docs/k3s/latest/en/quick-start/ https://rancher.com/docs/k3s/latest/en/installation/airgap/ "},"base/pod.html":{"url":"base/pod.html","title":"Pod(容器集)","keywords":"","body":"Pod(容器集) Pod Pod 是包含一个或多个容器的容器组，是 Kubernetes 中创建和管理的最小对象。 Pod 有以下特点： Pod 是 kubernetes 中$\\color{red}{最小的调度单位}$（原子单元），Kubernetes 直接管理 Pod 而不是容器。 同一个 Pod 中的容器总是会被自动安排到集群中的$\\color{red}{同一节点}$（物理机或虚拟机）上，并且$\\color{red}{一起调度}$。 Pod 可以理解为运行特定应用的“逻辑主机”，这些容器共享存储、网络和配置声明(如资源限制)。 每个 Pod 有唯一的 IP 地址。 $\\color{red}{IP 地址分配给 Pod}$，在同一个 Pod 内，所有容器共享一个 IP 地址和端口空间，Pod 内的容器可以使用 localhost 互相通信。 例如，你可能有一个容器，为共享卷中的文件提供 Web 服务器支持，以及一个单独的 \"边车 (sidercar)\" 容器负责从远端更新这些文件，如下图所示： 创建和管理 Pod # 创建 mynginx pod 并使用容器镜像 nginx 的 1.22 版本 kubectl run mynginx --image=nginx:1.22 # 查看Pod kubectl get pod # 查看pod日志 kubectl logs -f mynginx # 查看pod描述信息 kubectl describe pod mynginx 访问 pod # 查看Pod详细信息(包含IP和运行节点信息) $ kubectl get pod -owide NAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODE READINESS GATES mynginx 1/1 Running 0 14m 10.42.2.5 k3d-demo-server-0 获取到访问的内容 # 使用Pod的ip+pod里面运行容器的端口 curl 10.42.2.5 # 或使用 wget wget -qO- http://10.42.2.5 容器中执行命令 #在容器中执行 kubectl exec mynginx -it -- /bin/bash #进入容器访问自身 curl localhost 运行 pod，退出后自动删除容器 # 运行 busybox 容器 kubectl run my-busybox --image=busybox -ti --rm # ping 主机ip ping {{host_ip}} # 退出 exit # 发现 pod 已不存在 kubectl get pod 删除容器 # 删除 mynginx kubectl delete pod mynginx # 强制删除 kubectl delete pod mynginx --force watch 模式 kubectl get pod --watch 镜像加速 由于 kubernetes 从V1.24版本开始默认使用containerd，需要修改containerd的配置文件，才能让 Pod 的镜像使用镜像加速器。 配置文件路径一般为/etc/containerd/config.toml，详见阿里云镜像加速。 在 K3s 中配置镜像仓库 K3s 会自动生成 containerd 的配置文件/var/lib/rancher/k3s/agent/etc/containerd/config.toml,不要直接修改这个文件，k3s 重启后修改会丢失。 为了简化配置，K3s 通过/etc/rancher/k3s/registries.yaml文件来配置镜像仓库，K3s 会在启动时检查这个文件是否存在。 我们需要在每个节点上新建/etc/rancher/k3s/registries.yaml文件，配置内容如下： mirrors: docker.io: endpoint: - \"https://fsp2sfpr.mirror.aliyuncs.com/\" 重启每个节点 systemctl restart k3s systemctl restart k3s-agent 查看配置是否生效。 cat /var/lib/rancher/k3s/agent/etc/containerd/config.toml 容器与镜像 容器运行时接口（CRI） Kubelet 运行在每个节点(Node)上,用于管理和维护 Pod 和容器的状态。 容器运行时接口（CRI）是 kubelet 和容器运行时之间通信的主要协议。它将 Kubelet 与容器运行时解耦，理论上，实现了 CRI 接口的容器引擎，都可以作为 kubernetes 的容器运行时。 Docker没有实现（CRI）接口，Kubernetes使用dockershim来兼容docker。 自V1.24版本起，Dockershim 已从 Kubernetes 项目中移除。 crictl是一个兼容 CRI 的容器运行时命令，他的用法跟 docker 命令一样，可以用来检查和调试底层的运行时容器。 crictl pull mysql:5.7-debian crictl images 在一些局域网环境下，我们没法通过互联网拉取镜像，可以手动的导出、导入镜像。 crictl 命令没有导出、导入镜像的功能。 需要使用 ctr 命令导出、导入镜像，它是 containerd 的命令行接口。 从docker导出镜像再导入到containerd中 docker pull alpine:3.16 docker save alpine:3.16 > alpine.tar #kubernetes使用的镜像都在k8s.io命名空间中 ctr -n k8s.io images import alpine.tar 从containerd导出、导入镜像 #导出镜像 ctr -n k8s.io images export mysql.tar docker.io/library/mysql:5.7-debian --platform linux/amd64 #导入镜像 ctr -n k8s.io images import mysql.tar 参考文档：https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/ https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands https://kubernetes.io/zh-cn/docs/tasks/debug/debug-cluster/crictl/ https://docs.k3s.io/installation/private-registry "}}