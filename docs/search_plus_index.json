{"./":{"url":"./","title":"Kubernetes 课程导读","keywords":"","body":"k8s 课程导读 a note use gitbook for Kubernetes 二小时入门教程, 根据自己的学习会做一些添加和补充, 防止羽雀又崩了, 2023-10-23 崩过 😂 B 站视频地址 https://www.bilibili.com/video/BV1k24y197KC 原文档地址 https://www.yuque.com/wukong-zorrm/qdoy5p 为什么 Kubernetes 学起来很难？ zh Kubernetes 本身比较复杂，组件众多，安装过程比较麻烦 本课程使用 K3s 快速创建学习环境，不要把时间和精力浪费在搭环境上 网络问题，许多谷歌镜像或软件仓库访问不到，拉取失败 配置阿里云镜像加速 手动拉取镜像、手动导出、导入镜像 Kubernetes 版本有重大变化，网上好多教程已过时 kubernetes 从 1.24 版本开始，移除了对 docker 的支持 本课程采用 1.25 版本，使用 containerd 作为容器运行时 课程中对 containerd 用法以及可能遇到的问题进行了说明 官方文档有错误，许多例子或命令运行不起来 本课程会帮你避过官方文档中的坑 很多教程只有例子，没有实战，导致“一学就会，一用就废” 本课程会演示常用中间件的安装（MySQL 主从集群、Redis 主从集群） 本课程会演示如何在 K8s 上运行一个完整的应用 应用程序包括前端(node/nginx)、缓存(redis)、数据库(mysql)、后端(java） "},"base/":{"url":"base/","title":"Kubernetes 基础","keywords":"","body":""},"base/intro.html":{"url":"base/intro.html","title":"Kubernetes 简介","keywords":"","body":"Kubernetes 简介 简介 Kubernetes 是一个开源的容器编排引擎和容器集群管理工具，用来对容器化应用进行自动化部署、 扩缩和管理。 Kubernetes 这个名字源于希腊语，意为“舵手”或“飞行员”。k8s 这个缩写是因为 k 和 s 之间有 8 个字符。 Google 在 2014 年开源了 Kubernetes 项目。 优势 Kubernetes 建立在 Google 大规模运行生产工作负载十几年经验的基础上， 结合了社区中最优秀的想法和实践。它之所以能够迅速流行起来，是因为它的许多功能高度契合互联网大厂的部署和运维需求。 Kubernetes 可以提供： 服务发现和负载均衡 Kubernetes 可以使用 DNS 名称或自己的 IP 地址来曝露容器。 如果进入容器的流量很大 Kubernetes 可以负载均衡并分配网络流量，从而使部署稳定。 存储编排 Kubernetes 允许你自动挂载你选择的存储系统，例如本地存储、公共云提供商等。 自动部署和回滚 你可以使用 Kubernetes 描述已部署容器的所需状态， 它可以以受控的速率将实际状态更改为期望状态。 例如，你可以自动化 Kubernetes 来为你的部署创建新容器， 删除现有容器并将它们的所有资源用于新容器。也可以是方便的实现金丝雀部署(canary deployment )。 自动完成装箱计算 你为 Kubernetes 提供许多节点组成的集群，在这个集群上运行容器化的任务。 你告诉 Kubernetes 每个容器需要多少 CPU 和内存 (RAM)。 Kubernetes 可以将这些容器按实际情况调度到你的节点上，以最佳方式利用你的资源。 自我修复 Kubernetes 将重新启动失败的容器、替换容器、杀死不响应用户定义的运行状况检查的容器， 并且在准备好服务之前不将其通告给客户端。 密钥与配置管理 ubernetes 允许你存储和管理敏感信息，例如密码、OAuth 令牌和 ssh 密钥。 你可以在不重建容器镜像的情况下部署和更新密钥和应用程序配置，也无需在堆栈配置中暴露密钥。 云原生 2015 年由 Google、Redhat 等大型云计算厂商以及一些开源公司共同牵头成立了 Cloud Native Computing Foundation（云原生计算基金会）。 云原生计算基金会（CNCF）致力于培育和维护一个厂商中立的开源生态系统，来推广云原生技术。 云原生的概念从此广泛传播。 云原生定义 Kubernetes 是 CNCF 托管的第一个开源项目。因此现在提到云原生，往往我们都把它与 kubernetes 联系起来。 通俗解释 使用 Java、Go、PHP、Python 等语言开发的应用我们称之为原生应用，在设计和开发这些应用时，使他们能够运行在云基础设施(或 kubernetes)上，从而使应用具备可弹性扩展的能力，我们称之为云原生应用。我们可以将云原生理解为以容器技术为载体、基于微服务架构思想的一套技术体系和方法论。 官方定义 云原生技术有利于各组织在公有云、私有云和混合云等新型动态环境中，构建和运行可弹性扩展的应用。云原生的代表技术包括容器、服务网格、微服务、不可变基础设施和声明式API。 这些技术能够构建容错性好、易于管理和便于观察的松耦合系统。结合可靠的自动化手段，云原生技术使工程师能够轻松地对系统作出频繁和可预测的重大变更。 微服务 在 Kubernetes 之前，Pivotal（开源 Java 开发框架 Spring 的母公司，后被 VMware 收购）是云原生应用的提出者，并推出了 Pivotal Cloud Foundry 云原生应用平台和 Spring Cloud 开发框架，成为云原生应用架构中先驱者和探路者。Spring Cloud 通过微服务架构，使程序具备可拓展性和在分布式环境运行的能力。Spring Cloud 和 Kubernetes 有很多功能是重合的，例如： 服务注册和发现 API 网关 负载均衡 配置管理 但是 Spring Cloud 只能用于 Java 应用开发，而 kubernetes 是语言无关的，可以用于各种语言开发的应用。 文档参考:https://kubernetes.io/zh-cn/docs/concepts/overview/ https://github.com/cncf/toc/blob/main/DEFINITION.md "},"base/architecture.html":{"url":"base/architecture.html","title":"Kubernetes 架构","keywords":"","body":"kubernetes 架构 kubernetes 架构 一个 Kubernetes 集群至少包含一个控制平面(control plane)，以及一个或多个工作节点(worker node)。 控制平面(Control Plane) : 控制平面负责管理工作节点和维护集群状态。所有任务分配都来自于控制平面。 工作节点(Worker Node) : 工作节点负责执行由控制平面分配的请求任务,运行实际的应用和工作负载。 控制平面 控制平面组件会为集群做出全局决策，比如资源的调度、检测和响应集群事件。 kube-apiserver 如果需要与 Kubernetes 集群进行交互，就要通过 API。 apiserver是 Kubernetes 控制平面的前端，用于处理内部和外部请求。 kube-scheduler 集群状况是否良好？如果需要创建新的容器，要将它们放在哪里？这些是调度程序需要关注的问题。 scheduler调度程序会考虑容器集的资源需求（例如 CPU 或内存）以及集群的运行状况。随后，它会将容器集安排到适当的计算节点。 etcd etcd 是一个键值对数据库，用于存储配置数据和集群状态信息。 kube-controller-manager 控制器负责实际运行集群，controller-manager 控制器管理器则是将多个控制器功能合而为一，降低了程序的复杂性。 controller-manager 包含了这些控制器： 节点控制器（Node Controller）：负责在节点出现故障时进行通知和响应 任务控制器（Job Controller）：监测代表一次性任务的 Job 对象，然后创建 Pods 来运行这些任务直至完成 端点控制器（Endpoints Controller）：填充端点（Endpoints）对象（即加入 Service 与 Pod） 服务帐户和令牌控制器（Service Account & Token Controllers）：为新的命名空间创建默认帐户和 API 访问令牌 Node 组件 节点组件会在每个节点上运行，负责维护运行的 Pod 并提供 Kubernetes 运行环境。 kubelet kubelet 会在集群中每个节点（node）上运行。 它保证容器（containers）都运行在 Pod 中。 当控制平面需要在节点中执行某个操作时，kubelet 就会执行该操作。 kube-proxy kube-proxy 是集群中每个节点（node）上运行的网络代理，是实现 Kubernetes 服务（Service） 概念的一部分。 kube-proxy 维护节点网络规则和转发流量，实现从集群内部或外部的网络与 Pod 进行网络通信。 容器运行时（Container Runtime） 这个基础组件使 Kubernetes 能够有效运行容器。 它负责管理 Kubernetes 环境中容器的执行和生命周期。 Kubernetes 支持许多容器运行环境，例如 containerd、 docker 以及 Kubernetes CRI (容器运行环境接口) 的其他任何实现。 组件关系 cloud-controller-manager 控制平面还包含一个可选组件cloud-controller-manager。 云控制器管理器（Cloud Controller Manager）允许你将你的集群连接到云提供商的 API 之上， 并将与该云平台交互的组件同与你的集群交互的组件分离开来。 如果在自己的环境中运行 Kubernetes，或者在本地计算机中运行学习环境， 所部署的集群不需要有云控制器管理器。 参考资料：https://kubernetes.io/zh-cn/docs/concepts/overview/components/ https://www.redhat.com/zh/topics/containers/kubernetes-architecture "},"base/minikube.html":{"url":"base/minikube.html","title":"安装 Minikube","keywords":"","body":"安装 Minikube docker-desktop 新版本自带了 kubenetes, 不需要使用 minikube 了。 自带的安装较慢可以使用 https://github.com/AliyunContainerService/k8s-for-docker-desktop 去安装 kubenetes 和 dashboard dashbord https://github.com/kubernetes/dashboard 安装官方控制台 kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.7.0/aio/deploy/recommended.yaml 查看是否允许成功 $ kubectl get pods -A NAMESPACE NAME READY STATUS RESTARTS AGE kube-system coredns-5d78c9869d-tjhgv 1/1 Running 5 (7m45s ago) 2d22h kube-system coredns-5d78c9869d-vbzjn 1/1 Running 5 (7m45s ago) 2d22h kube-system etcd-docker-desktop 1/1 Running 5 (7m49s ago) 2d22h kube-system kube-apiserver-docker-desktop 1/1 Running 5 (7m40s ago) 2d22h kube-system kube-controller-manager-docker-desktop 1/1 Running 5 (7m50s ago) 2d22h kube-system kube-proxy-nrmkx 1/1 Running 5 (7m50s ago) 2d22h kube-system kube-scheduler-docker-desktop 1/1 Running 5 (7m50s ago) 2d22h kube-system storage-provisioner 1/1 Running 9 (6m28s ago) 2d22h kube-system vpnkit-controller 1/1 Running 5 (7m50s ago) 2d22h kubernetes-dashboard dashboard-metrics-scraper-5cb4f4bb9c-ws8sk 1/1 Running 1 (7m50s ago) 11m kubernetes-dashboard kubernetes-dashboard-6967859bff-5tvh6 1/1 Running 1 (7m50s ago) 11m 以上后 2 行出现代表成功 启用 dashboard kubectl proxy kubectl 会使得 Dashboard 可以通过 http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/ 访问。 UI 只能 通过执行这条命令的机器进行访问。 以上需要访问令牌 参考 https://github.com/AliyunContainerService/k8s-for-docker-desktop 部署访问令牌 授权 kube-system 默认服务账号 kubectl apply -f https://raw.githubusercontent.com/AliyunContainerService/k8s-for-docker-desktop/master/kube-system-default.yaml 获取 token windows $TOKEN=((kubectl -n kube-system describe secret default | Select-String \"token:\") -split \" +\")[1] kubectl config set-credentials docker-desktop --token=\"${TOKEN}\" echo $TOKEN or linux TOKEN=$(kubectl -n kube-system describe secret default| awk '$1==\"token:\"{print $2}') kubectl config set-credentials docker-desktop --token=\"${TOKEN}\" echo $TOKEN 生成好后在以下路径 powershell: %UserProfile%\\.kube\\config or sh: $HOME/.kube/config "},"base/env_k3s.html":{"url":"base/env_k3s.html","title":"使用 K3s 快速搭建集群","keywords":"","body":"使用 K3s 快速搭建集群 提示： 1.本课程基于kubernetes V1.25版本。提示： 2.从V1.24开始，kubernetes默认容器运行时使用containerd，不再使用docker。 为什么使用 K3s K3s 是一个轻量级的、$\\color{red}{完全兼容}$的 Kubernetes 发行版本。非常适合初学者。 K3s 将所有 Kubernetes 控制平面组件都封装在单个二进制文件和进程中，文件大小 提示： K3s完全兼容kubernetes，二者的操作是一样的，使用k3s完全满足我们学习kubernetes的要求，课程的最后，我们再使用kubeadm安装一个完整的集群。 离线安装 K3s 集群 K3s 集群分为 k3s Server(控制平面)和 k3s Agent(工作节点)。所有的组件都打包在单个二进制文件中。 运行环境 最低运行要求 内存: 512MB / CPU: 1 核心 K3s 版本：v1.25.0+k3s1 集群规划 主机名 IP 地址 配置 系统 网络 k8s-master 192.168.56.109 内存：2GCPU：2核硬盘：20G CentOS7.9.2009最小化安装 互联网:NAT网络内部网络: Host-only k8s-worker1 192.168.56.111 k8s-worker2 192.168.56.112 ps 每个主机需要设置 hostname k8s-master hostnamectl set-hostname k8s-master k8s-worker # k8s-worker1 hostnamectl set-hostname k8s-worker1 # k8s-worker2 hostnamectl set-hostname k8s-worker2 1.准备工作 需要在每台机器上执行如下命令： 关闭防火墙 设置 selinux(需要联网) systemctl disable firewalld --now yum install -y container-selinux selinux-policy-base yum install -y https://rpm.rancher.io/k3s/latest/common/centos/7/noarch/k3s-selinux-0.2-1.el7_8.noarch.rpm 2.下载安装包 下载安装脚本 install.sh：https://get.k3s.io/ 下载 k3s 二进制文件：k3s 下载必要的 image：离线安装需要的 image 文件 这些文件都可以在github仓库中获取：https://github.com/k3s-io/k3s 3.执行安装脚本 将k3s二进制文件移动到/usr/local/bin 目录，并添加执行权限 mv k3s /usr/local/bin chmod +x /usr/local/bin/k3s 将镜像移动到/var/lib/rancher/k3s/agent/images/目录（无需解压） mkdir -p /var/lib/rancher/k3s/agent/images/ cp ./k3s-airgap-images-amd64.tar.gz /var/lib/rancher/k3s/agent/images/ 在k8s-master节点执行： #修改权限 chmod +x install.sh #离线安装 INSTALL_K3S_SKIP_DOWNLOAD=true ./install.sh #安装完成后，查看节点状态 kubectl get node #查看token cat /var/lib/rancher/k3s/server/node-token #K10c4b79481685b50e4bca2513078f4e83b62d1d0b5f133a8a668b65c8f9249c53e::server:bf7b63be7f3471838cbafa12c1a1964d 在k8s-worker1和k8s-worker2节点执行 INSTALL_K3S_SKIP_DOWNLOAD=true \\ K3S_URL=https://192.168.56.109:6443 \\ K3S_TOKEN=K1012bdc3ffe7a5d89ecb125e56c38f9fe84a9f9aed6db605f7698fa744f2f2f12f::server:fdf33f4921dd607cadf2ae3c8eaf6ad9 \\ ./install.sh 排查错误 如果安装或启动不成功，可能有以下几个原因： 1. 时间不统一 2. IP有冲突，请为每个主机分配不同的IP 3. 主机名(hostname)重复，请为每个主机设置不同的主机名 4. 网卡的MAC有冲突，复制虚拟机时，请为所有网卡重新生产MAC地址 参考文档： https://k3s.io/ https://rancher.com/docs/k3s/latest/en/ https://rancher.com/docs/k3s/latest/en/quick-start/ https://rancher.com/docs/k3s/latest/en/installation/airgap/ "},"base/pod.html":{"url":"base/pod.html","title":"Pod(容器集)","keywords":"","body":"Pod(容器集) Pod Pod 是包含一个或多个容器的容器组，是 Kubernetes 中创建和管理的最小对象。 Pod 有以下特点： Pod 是 kubernetes 中$\\color{red}{最小的调度单位}$（原子单元），Kubernetes 直接管理 Pod 而不是容器。 同一个 Pod 中的容器总是会被自动安排到集群中的$\\color{red}{同一节点}$（物理机或虚拟机）上，并且$\\color{red}{一起调度}$。 Pod 可以理解为运行特定应用的“逻辑主机”，这些容器共享存储、网络和配置声明(如资源限制)。 每个 Pod 有唯一的 IP 地址。 $\\color{red}{IP 地址分配给 Pod}$，在同一个 Pod 内，所有容器共享一个 IP 地址和端口空间，Pod 内的容器可以使用 localhost 互相通信。 例如，你可能有一个容器，为共享卷中的文件提供 Web 服务器支持，以及一个单独的 \"边车 (sidercar)\" 容器负责从远端更新这些文件，如下图所示： 创建和管理 Pod # 创建 mynginx pod 并使用容器镜像 nginx 的 1.22 版本 kubectl run mynginx --image=nginx:1.22 # 查看Pod kubectl get pod # 查看pod日志 kubectl logs -f mynginx # 查看pod描述信息 kubectl describe pod mynginx 访问 pod # 查看Pod详细信息(包含IP和运行节点信息) $ kubectl get pod -owide NAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODE READINESS GATES mynginx 1/1 Running 0 14m 10.42.2.5 k3d-demo-server-0 获取到访问的内容 # 使用Pod的ip+pod里面运行容器的端口 curl 10.42.2.5 # 或使用 wget wget -qO- http://10.42.2.5 容器中执行命令 #在容器中执行 kubectl exec mynginx -it -- /bin/bash #进入容器访问自身 curl localhost 运行 pod，退出后自动删除容器 # 运行 busybox 容器 kubectl run my-busybox --image=busybox -ti --rm # ping 主机ip ping {{host_ip}} # 退出 exit # 发现 pod 已不存在 kubectl get pod 删除容器 # 删除 mynginx kubectl delete pod mynginx # 强制删除 kubectl delete pod mynginx --force watch 模式 kubectl get pod --watch 镜像加速 由于 kubernetes 从V1.24版本开始默认使用containerd，需要修改containerd的配置文件，才能让 Pod 的镜像使用镜像加速器。 配置文件路径一般为/etc/containerd/config.toml，详见阿里云镜像加速。 在 K3s 中配置镜像仓库 K3s 会自动生成 containerd 的配置文件/var/lib/rancher/k3s/agent/etc/containerd/config.toml,不要直接修改这个文件，k3s 重启后修改会丢失。 为了简化配置，K3s 通过/etc/rancher/k3s/registries.yaml文件来配置镜像仓库，K3s 会在启动时检查这个文件是否存在。 我们需要在每个节点上新建/etc/rancher/k3s/registries.yaml文件，配置内容如下： mirrors: docker.io: endpoint: - \"https://fsp2sfpr.mirror.aliyuncs.com/\" 重启每个节点 systemctl restart k3s systemctl restart k3s-agent 查看配置是否生效。 cat /var/lib/rancher/k3s/agent/etc/containerd/config.toml 容器与镜像 容器运行时接口（CRI） Kubelet 运行在每个节点(Node)上,用于管理和维护 Pod 和容器的状态。 容器运行时接口（CRI）是 kubelet 和容器运行时之间通信的主要协议。它将 Kubelet 与容器运行时解耦，理论上，实现了 CRI 接口的容器引擎，都可以作为 kubernetes 的容器运行时。 Docker没有实现（CRI）接口，Kubernetes使用dockershim来兼容docker。 自V1.24版本起，Dockershim 已从 Kubernetes 项目中移除。 crictl是一个兼容 CRI 的容器运行时命令，他的用法跟 docker 命令一样，可以用来检查和调试底层的运行时容器。 查看容器和镜像 # 查看容器 $ crictl ps CONTAINER IMAGE CREATED STATE NAME ATTEMPT POD ID POD 47aaa00baba1e 0f8498f13f3ad 7 hours ago Running nginx 0 ad79f75bc4e04 nginx-deploy-5964889c54-fkd8t 2c47bdd5aaa26 ead0a4a53df89 3 days ago Running coredns 10 05fbcfa8067b8 coredns-77ccd57875-rf6s4 f1bcf4785b184 af74bd845c4a8 3 days ago Running lb-tcp-443 1 d793ffcccf6fe svclb-traefik-c090484e-cnsgm 2cc1af75acf27 af74bd845c4a8 3 days ago Running lb-tcp-80 1 d793ffcccf6fe svclb-traefik-c090484e-cnsgm # 查看镜像 $ crictl images IMAGE TAG IMAGE ID SIZE docker.io/library/nginx 1.22 0f8498f13f3ad 57MB docker.io/library/nginx 1.23 a7be6198544f0 57MB docker.io/rancher/klipper-helm v0.8.0-build20230510 6f42df210d7fa 95MB docker.io/rancher/klipper-lb v0.4.4 af74bd845c4a8 4.92MB docker.io/rancher/mirrored-coredns-coredns 1.10.1 ead0a4a53df89 16.2MB docker.io/rancher/mirrored-pause 3.6 6270bb605e12e 301kB crictl 命令 命令相对 docker 少一些，比如无法导入导出镜像 $ crictl -h NAME: crictl - client for CRI USAGE: crictl [global options] command [command options] [arguments...] VERSION: v1.26.0-rc.0-k3s1 COMMANDS: attach Attach to a running container create Create a new container exec Run a command in a running container version Display runtime version information images, image, img List images inspect Display the status of one or more containers inspecti Return the status of one or more images imagefsinfo Return image filesystem info inspectp Display the status of one or more pods logs Fetch the logs of a container port-forward Forward local port to a pod ps List containers pull Pull an image from a registry run Run a new container inside a sandbox runp Run a new pod rm Remove one or more containers rmi Remove one or more images rmp Remove one or more pods pods List pods start Start one or more created containers info Display information of the container runtime stop Stop one or more running containers stopp Stop one or more running pods update Update one or more running containers config Get and set crictl client configuration options stats List container(s) resource usage statistics statsp List pod resource usage statistics completion Output shell completion code checkpoint Checkpoint one or more running containers help, h Shows a list of commands or help for one command GLOBAL OPTIONS: --config value, -c value Location of the client config file. If not specified and the default does not exist, the program's directory is searched as well (default: \"/etc/crictl.yaml\") [$CRI_CONFIG_FILE] --debug, -D Enable debug mode (default: false) --image-endpoint value, -i value Endpoint of CRI image manager service (default: uses 'runtime-endpoint' setting) [$IMAGE_SERVICE_ENDPOINT] --runtime-endpoint value, -r value Endpoint of CRI container runtime service (default: uses in order the first successful one of [unix:///run/k3s/containerd/containerd.sock unix:///var/run/dockershim.sock unix:///run/containerd/containerd.sock unix:///run/crio/crio.sock unix:///var/run/cri-dockerd.sock]). Default is now deprecated and the endpoint should be set instead. [$CONTAINER_RUNTIME_ENDPOINT] --timeout value, -t value Timeout of connecting to the server in seconds (e.g. 2s, 20s.). 0 or less is set to default (default: 2s) --help, -h show help (default: false) --version, -v print the version (default: false) 在一些局域网环境下，我们没法通过互联网拉取镜像，可以手动的导出、导入镜像。 crictl 命令没有导出、导入镜像的功能。 需要使用 ctr 命令导出、导入镜像，它是 containerd 的命令行接口。 # 只需要掌握导入导出镜像即可 $ ctr -h NAME: ctr - __ _____/ /______ / ___/ __/ ___/ / /__/ /_/ / \\___/\\__/_/ containerd CLI USAGE: ctr [global options] command [command options] [arguments...] VERSION: v1.7.1-k3s1 DESCRIPTION: ctr is an unsupported debug and administrative client for interacting with the containerd daemon. Because it is unsupported, the commands, options, and operations are not guaranteed to be backward compatible or stable from release to release of the containerd project. COMMANDS: plugins, plugin Provides information about containerd plugins version Print the client and server versions containers, c, container Manage containers content Manage content events, event Display containerd events images, image, i Manage images leases Manage leases namespaces, namespace, ns Manage namespaces pprof Provide golang pprof outputs for containerd run Run a container snapshots, snapshot Manage snapshots tasks, t, task Manage tasks install Install a new package oci OCI tools sandboxes, sandbox, sb, s Manage sandboxes info Print the server info shim Interact with a shim directly help, h Shows a list of commands or help for one command GLOBAL OPTIONS: --debug Enable debug output in logs --address value, -a value Address for containerd's GRPC server (default: \"/run/k3s/containerd/containerd.sock\") [$CONTAINERD_ADDRESS] --timeout value Total timeout for ctr commands (default: 0s) --connect-timeout value Timeout for connecting to containerd (default: 0s) --namespace value, -n value Namespace to use with commands (default: \"k8s.io\") [$CONTAINERD_NAMESPACE] --help, -h show help --version, -v print the version 从docker导出镜像再导入到containerd中 $ docker pull alpine:3.15 $ docker save alpine:3.15 > alpine-3.15.tar # 将tar拷贝到对应k8s主机 #kubernetes使用的镜像都在k8s.io命名空间中, 需要制定对应平台，如linux/amd64 $ ctr -n k8s.io images import alpine-3.15.tar --platform linux/amd64 unpacking docker.io/library/alpine:3.15 (sha256:69ba0f584ebec4ccf2ccf44817931f3facfb924380355466495274b2e273fe7b)...done # 可以看到镜像导入了 $ crictl images IMAGE TAG IMAGE ID SIZE docker.io/library/alpine 3.15 d51a1e6a80db9 5.87MB 。。。 从containerd导出、导入镜像 #导出镜像 ctr -n k8s.io images export alpine.tar docker.io/library/alpine:3.15 --platform linux/amd64 参考文档：https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/ https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands https://kubernetes.io/zh-cn/docs/tasks/debug/debug-cluster/crictl/ https://docs.k3s.io/installation/private-registry "},"base/deployment_replicaset.html":{"url":"base/deployment_replicaset.html","title":"Deployment(部署)与 ReplicaSet(副本集)","keywords":"","body":"Deployment(部署)与 ReplicaSet(副本集) Deployment是对 ReplicaSet 和 Pod 更高级的抽象。 它使 Pod 拥有多副本，自愈，扩缩容、滚动升级等能力。 ReplicaSet(副本集)是一个 Pod 的集合。 它可以设置运行 Pod 的数量，确保任何时间都有指定数量的 Pod 副本在运行。 通常我们不直接使用 ReplicaSet，而是在 Deployment 中声明。 #创建deployment,部署3个运行nginx的Pod $ kubectl create deployment nginx-deploy --image=nginx:1.22 --replicas=3 #查看deployment(缩写成deploy) $ kubectl get deploy # 查看pod $ kubectl get pod NAME READY STATUS RESTARTS AGE nginx-deploy-5964889c54-zmk6p 1/1 Running 0 6m1s nginx-deploy-5964889c54-th9f8 1/1 Running 0 6m1s nginx-deploy-5964889c54-28689 1/1 Running 0 6m1s #查看replicaSet(缩写为rs) $ kubectl get replicaSet NAME DESIRED CURRENT READY AGE nginx-deploy-5964889c54 3 3 3 7m13s 可以看到 5964889c54 为副本集 ， 有 3 个 pod 分别为 zmk6p、th9f8、28689 删除最后一个 pod 会再生成新的 pod $ kubectl delete pod nginx-deploy-5964889c54-28689 pod \"nginx-deploy-5964889c54-28689\" deleted # 可以看到生成了新的pod k9xnj，体现了 deploy 使pod拥有的自愈能力 $ kubectl get pod NAME READY STATUS RESTARTS AGE nginx-deploy-5964889c54-zmk6p 1/1 Running 0 9m29s nginx-deploy-5964889c54-th9f8 1/1 Running 0 9m29s nginx-deploy-5964889c54-k9xnj 1/1 Running 0 13s 缩放 手动缩放 # 副本扩容到5个 $ kubectl scale deploy nginx-deploy --replicas=5 扩容过程 # DESIRED 目标 CURRENT 当前 READY 准备就绪 $ kubectl get rs --watch NAME DESIRED CURRENT READY AGE nginx-deploy-5964889c54 3 3 3 12m nginx-deploy-5964889c54 5 3 3 13m // Step A nginx-deploy-5964889c54 5 3 3 13m nginx-deploy-5964889c54 5 4 3 13m // Step B nginx-deploy-5964889c54 5 5 3 13m // Step C nginx-deploy-5964889c54 5 5 4 13m // Step D nginx-deploy-5964889c54 5 5 5 13m // Step E 可以看到在观测副本时过程 执行了扩容后 DESIRED 就变成了 5 (Step A) CURRENT 变成 4， 证明 启动了一个 pod，READY 还是 3， 说明还没启动完成 (Step B) CURRENT 变成 5， 证明 又启动了一个 pod，READY 还是 3， 说明还没启动完成 (Step C) READY 变成了 4， 说明成功运行了一个 pod (Step D) READY 变成了 5， 说明又成功运行了一个 pod, 这样 READY 和 DESIRED 相等，扩容完成 (Step D) 调整回去 $ kubectl scale deploy nginx-deploy --replicas=3 过程 $ kubectl get rs --watch NAME DESIRED CURRENT READY AGE nginx-deploy-5964889c54 5 5 5 27m nginx-deploy-5964889c54 3 5 5 28m nginx-deploy-5964889c54 3 5 5 28m nginx-deploy-5964889c54 3 3 3 28m 自动缩放 自动缩放通过增加和减少副本的数量，以保持所有 Pod 的平均 CPU 利用率不超过 75%。 自动伸缩需要声明 Pod 的资源限制，同时使用 Metrics Server 服务（K3s 默认已安装）。 本例仅用来说明kubectl autoscale命令的使用，完整示例参考：HPA演示 #自动缩放 kubectl autoscale deployment/nginx-auto --min=3 --max=10 --cpu-percent=75 #查看自动缩放 kubectl get hpa #删除自动缩放 kubectl delete hpa nginx-deployment 滚动更新 设置镜像为 1.23 $ kubectl set image deploy/nginx-deploy nginx=nginx:1.23 # 查看滚动更新状态 $ kubectl rollout status deployment/nginx-deploy deployment \"nginx-deploy\" successfully rolled out 查看更新后的版本和 pod $ kubectl get deploy/nginx-deploy -owide NAME READY UP-TO-DATE AVAILABLE AGE CONTAINERS IMAGES SELECTOR nginx-deploy 3/3 3 3 39m nginx nginx:1.23 app=nginx-deploy 过程及说明 $ kubectl get rs --watch NAME DESIRED CURRENT READY AGE nginx-deploy-5964889c54 3 3 3 35m nginx-deploy-7c88b8c7c9 1 0 0 0s // Step 1 nginx-deploy-7c88b8c7c9 1 0 0 0s nginx-deploy-7c88b8c7c9 1 1 0 0s // Step 2 nginx-deploy-7c88b8c7c9 1 1 1 22s // Step 3 nginx-deploy-5964889c54 2 3 3 37m // Step 4 nginx-deploy-5964889c54 2 3 3 37m nginx-deploy-5964889c54 2 2 2 37m // Step 5 nginx-deploy-7c88b8c7c9 2 1 1 23s // Step 6 nginx-deploy-7c88b8c7c9 2 1 1 23s nginx-deploy-7c88b8c7c9 2 2 1 23s nginx-deploy-7c88b8c7c9 2 2 2 43s // Step 7 nginx-deploy-5964889c54 1 2 2 37m nginx-deploy-7c88b8c7c9 3 2 2 43s nginx-deploy-5964889c54 1 2 2 37m nginx-deploy-5964889c54 1 1 1 37m nginx-deploy-7c88b8c7c9 3 2 2 43s nginx-deploy-7c88b8c7c9 3 3 2 43s nginx-deploy-7c88b8c7c9 3 3 3 63s nginx-deploy-5964889c54 0 1 1 37m nginx-deploy-5964889c54 0 1 1 37m nginx-deploy-5964889c54 0 0 0 37m 可以看到 7c88b8c7c9 为新部署 nginx 的 deploy， 5964889c54 为 之前部署的 nginx 的 deploy step: 新 deploy 目标为 1 个 pod，当前和就绪为 0 新 deploy 1 个正在 启动 新 deploy 成功启动 1 个 旧 deploy 准备减少一个 旧 deploy 减少一个完成 新 deploy 准备再起 1 个 pod 新 deploy 成功又启动了 1 个 pod 后续步骤同理直到 新 deploy 满足要求 旧 deploy 停止所有 pod，副本集清 0 版本回滚 #查看历史版本 $ kubectl rollout history deployment/nginx-deploy deployment.apps/nginx-deploy REVISION CHANGE-CAUSE 1 2 # 查看版本1详情 5964889c54 为版本1 hash值 $ kubectl rollout history deployment/nginx-deploy --revision=1 deployment.apps/nginx-deploy with revision #1 Pod Template: Labels: app=nginx-deploy pod-template-hash=5964889c54 Containers: nginx: Image: nginx:1.22 Port: Host Port: Environment: Mounts: Volumes: #回滚到历史版本 $ kubectl rollout undo deployment/nginx-deploy --to-revision=1 deployment.apps/nginx-deploy rolled back 回滚过程 $ kubectl get rs --watch NAME DESIRED CURRENT READY AGE nginx-deploy-7c88b8c7c9 3 3 3 20m nginx-deploy-5964889c54 0 0 0 57m nginx-deploy-5964889c54 0 0 0 57m nginx-deploy-5964889c54 1 0 0 57m nginx-deploy-5964889c54 1 0 0 57m nginx-deploy-5964889c54 1 1 0 57m nginx-deploy-5964889c54 1 1 1 57m nginx-deploy-7c88b8c7c9 2 3 3 21m nginx-deploy-7c88b8c7c9 2 3 3 21m nginx-deploy-5964889c54 2 1 1 57m nginx-deploy-7c88b8c7c9 2 2 2 21m nginx-deploy-5964889c54 2 1 1 57m nginx-deploy-5964889c54 2 2 1 57m nginx-deploy-5964889c54 2 2 2 57m nginx-deploy-7c88b8c7c9 1 2 2 21m nginx-deploy-5964889c54 3 2 2 57m nginx-deploy-7c88b8c7c9 1 2 2 21m nginx-deploy-7c88b8c7c9 1 1 1 21m nginx-deploy-5964889c54 3 2 2 57m nginx-deploy-5964889c54 3 3 2 57m nginx-deploy-5964889c54 3 3 3 57m nginx-deploy-7c88b8c7c9 0 1 1 21m nginx-deploy-7c88b8c7c9 0 1 1 21m nginx-deploy-7c88b8c7c9 0 0 0 21m 查看回滚后的状态 # 查看副本集状态 $ kubectl get rs NAME DESIRED CURRENT READY AGE nginx-deploy-5964889c54 3 3 3 59m nginx-deploy-7c88b8c7c9 0 0 0 22m # 查看pod状态，发现副本集回滚了 $ kubectl get pod NAME READY STATUS RESTARTS AGE nginx-deploy-5964889c54-fkd8t 1/1 Running 0 2m31s nginx-deploy-5964889c54-lnd79 1/1 Running 0 2m30s nginx-deploy-5964889c54-tfdf7 1/1 Running 0 2m28s 删除无用副本集 $ kubectl delete rs nginx-deploy-7c88b8c7c9 replicaset.apps \"nginx-deploy-7c88b8c7c9\" deleted 参考文档：https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/replicaset/ https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/ https://kubernetes.io/zh-cn/docs/tasks/run-application/horizontal-pod-autoscale-walkthrough/ "},"base/service.html":{"url":"base/service.html","title":"Service(服务)","keywords":"","body":"Service(服务) Service 将运行在一组 Pods 上的应用程序公开为网络服务的抽象方法。 Service 为一组 Pod 提供相同的 DNS 名，并且在它们之间进行负载均衡。 Kubernetes 为 Pod 提供分配了 IP 地址，但 IP 地址可能会发生变化。 集群内的容器可以通过 service 名称访问服务，而不需要担心 Pod 的 IP 发生变化。 Kubernetes Service 定义了这样一种抽象： 逻辑上的一组可以互相替换的 Pod，通常称为微服务。 Service 对应的 Pod 集合通常是通过选择算符来确定的。 举个例子，在一个 Service 中运行了 3 个 nginx 的副本。这些副本是可互换的，我们不需要关心它们调用了哪个 nginx，也不需要关注 Pod 的运行状态，只需要调用这个服务就可以了。 # 查看所有 $ kubectl get all NAME READY STATUS RESTARTS AGE pod/nginx-deploy-5964889c54-fkd8t 1/1 Running 0 8m37s pod/nginx-deploy-5964889c54-lnd79 1/1 Running 0 8m36s pod/nginx-deploy-5964889c54-tfdf7 1/1 Running 0 8m34s NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE service/kubernetes ClusterIP 10.43.0.1 443/TCP 4d12h NAME READY UP-TO-DATE AVAILABLE AGE deployment.apps/nginx-deploy 3/3 3 3 66m NAME DESIRED CURRENT READY AGE replicaset.apps/nginx-deploy-5964889c54 3 3 3 66m replicaset.apps/nginx-deploy-7c88b8c7c9 0 0 0 29m # 映射 pod 容器端口到服务器端口 $ kubectl expose deploy/nginx-deploy --name=nginx-service --port=8080 --target-port=80 service/nginx-service exposed # 查看service $ kubectl get service NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE kubernetes ClusterIP 10.43.0.1 443/TCP 4d12h nginx-service ClusterIP 10.43.146.225 8080/TCP 61s # 通过ip访问对应端口 $ wget -qO- http://10.43.146.225:8080 Welcome to nginx! html { color-scheme: light dark; } body { width: 35em; margin: 0 auto; font-family: Tahoma, Verdana, Arial, sans-serif; } Welcome to nginx! If you see this page, the nginx web server is successfully installed and working. Further configuration is required. For online documentation and support please refer to nginx.org. Commercial support is available at nginx.com. Thank you for using nginx. 集群内部可以通过 service 名称+ 端口访问 # 创建一次性的内部pod 来测试 $ kubectl run test -ti --image=nginx:1.22 --rm -- bash If you don't see a command prompt, try pressing enter. # 测试访问内部 root@test:/# curl nginx-service:8080 Welcome to nginx! html { color-scheme: light dark; } body { width: 35em; margin: 0 auto; font-family: Tahoma, Verdana, Arial, sans-serif; } Welcome to nginx! If you see this page, the nginx web server is successfully installed and working. Further configuration is required. For online documentation and support please refer to nginx.org. Commercial support is available at nginx.com. Thank you for using nginx. 查看 service 信息 # 可以看到对应IP 和 后端端点 $ kubectl describe service nginx-service Name: nginx-service Namespace: default Labels: app=nginx-deploy Annotations: Selector: app=nginx-deploy Type: ClusterIP IP Family Policy: SingleStack IP Families: IPv4 IP: 10.43.146.225 IPs: 10.43.146.225 Port: 8080/TCP TargetPort: 80/TCP Endpoints: 10.42.0.8:80,10.42.1.10:80,10.42.2.9:80 Session Affinity: None Events: # 获取pod信息 $ kubectl get pod NAME READY STATUS RESTARTS AGE nginx-deploy-5964889c54-fkd8t 1/1 Running 0 23m nginx-deploy-5964889c54-lnd79 1/1 Running 0 23m nginx-deploy-5964889c54-tfdf7 1/1 Running 0 23m # 进入其中一个pod 并将首页改为 hello $ kubectl exec -ti nginx-deploy-5964889c54-tfdf7 -- bash root@nginx-deploy-5964889c54-tfdf7:/# cd /usr/share/nginx/html/ root@nginx-deploy-5964889c54-tfdf7:/usr/share/nginx/html# echo hello > index.html 退出后多访问几次 会出现 hello, 可见其采用了负载均衡技术 $ wget -qO- http://10.43.146.225:8080 hello 创建 Service 对象 想从集群外部访问服务就需要定义 service 类型 ServiceType 取值 ClusterIP：将服务公开在集群内部。kubernetes 会给服务分配一个集群内部的 IP，集群内的所有主机都可以通过这个 Cluster-IP 访问服务。集群内部的 Pod 可以通过 service 名称访问服务。如果不指定 ServiceType，其为莫仍类型 NodePort：通过每个节点的主机 IP 和静态端口（NodePort）暴露服务。 集群的外部主机可以使用节点 IP 和 NodePort 访问服务。 $ 暴露一个外部端口的服务 $ kubectl expose deploy/nginx-deploy --name=nginx-outside --type=NodePort --port=8081 --target-port=80 service/nginx-outside exposed / # kubectl get service NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE kubernetes ClusterIP 10.43.0.1 443/TCP 4d13h nginx-service ClusterIP 10.43.146.225 8080/TCP 18m nginx-outside NodePort 10.43.4.121 8081:32555/TCP 9s # 通过节点ip访问 $ curl 172.25.0.2:32555 hello $ curl 172.25.0.2:32555 Welcome to nginx! html { color-scheme: light dark; } body { width: 35em; margin: 0 auto; font-family: Tahoma, Verdana, Arial, sans-serif; } Welcome to nginx! If you see this page, the nginx web server is successfully installed and working. Further configuration is required. For online documentation and support please refer to nginx.org. Commercial support is available at nginx.com. Thank you for using nginx. ExternalName：将集群外部的网络引入集群内部。 LoadBalancer：使用云提供商的负载均衡器向外部暴露服务。 访问 Service 前面 NodePort 访问主机：172.25.0.2:32555 1.NodePort端口是随机的，范围为:30000-32767。 2.集群中每一个主机节点的NodePort端口都可以访问。 3.如果需要指定端口，不想随机产生，需要使用配置文件来声明。 参考文档：https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/ https://kubernetes.io/zh-cn/docs/tutorials/stateless-application/expose-external-ip-address/ "},"base/namespace.html":{"url":"base/namespace.html","title":"Namespace(命名空间)","keywords":"","body":"Namespace(命名空间) 命名空间(Namespace)是一种资源隔离机制，将同一集群中的资源划分为相互隔离的组。 命名空间可以在多个用户之间划分集群资源（通过资源配额）。 例如我们可以设置开发、测试、生产等多个命名空间。 同一命名空间内的资源名称要唯一，但跨命名空间时没有这个要求。 命名空间作用域仅针对带有名字空间的对象，例如 Deployment、Service 等。 这种作用域对集群访问的对象不适用，例如 StorageClass、Node、PersistentVolume 等。 # 查看命名空间 缩写 ns $ kubectl get namespace NAME STATUS AGE default Active 4d15h kube-system Active 4d15h kube-public Active 4d15h kube-node-lease Active 4d15h Kubernetes 会创建四个初始命名空间： default 默认的命名空间，不可删除，未指定命名空间的对象都会被分配到 default 中。 kube-system Kubernetes 系统对象(控制平面和 Node 组件)所使用的命名空间。 kube-public 自动创建的公共命名空间，所有用户（包括未经过身份验证的用户）都可以读取它。通常我们约定，将整个集群中公用的可见和可读的资源放在这个空间中。 kube-node-lease 租约（Lease）对象使用的命名空间。每个节点都有一个关联的 lease 对象，lease 是一种轻量级资源。lease 对象通过发送心跳，检测集群中的每个节点是否发生故障。 使用 kubectl get lease -A 查看 lease 对象 kubenetes 的组件都运行在 kube-system 命名空间中, 自己部署的在 default 目录下 $ kubectl get pod -A NAMESPACE NAME READY STATUS RESTARTS AGE kube-system helm-install-traefik-crd-bjf84 0/1 Completed 0 4d15h kube-system helm-install-traefik-bcrr6 0/1 Completed 5 4d15h kube-system svclb-traefik-c090484e-hwms9 2/2 Running 2 (3d11h ago) 4d15h kube-system svclb-traefik-c090484e-4rlrg 2/2 Running 2 (3d11h ago) 4d15h kube-system coredns-77ccd57875-rf6s4 1/1 Running 10 (3d11h ago) 4d15h kube-system svclb-traefik-c090484e-cnsgm 2/2 Running 2 (3d11h ago) 4d15h kube-system local-path-provisioner-957fdf8bc-dw92l 1/1 Running 0 4d15h kube-system metrics-server-648b5df564-tnzrm 1/1 Running 30 (3d11h ago) 4d15h kube-system traefik-64f55bb67d-bhb49 1/1 Running 28 (3d11h ago) 4d15h default nginx-deploy-5964889c54-fkd8t 1/1 Running 0 152m default nginx-deploy-5964889c54-lnd79 1/1 Running 0 152m default nginx-deploy-5964889c54-tfdf7 1/1 Running 0 152m 新版本 apiserver 也是一个 lease 对象 $ kubectl get lease -A NAMESPACE NAME HOLDER AGE kube-node-lease k3d-demo-agent-0 k3d-demo-agent-0 4d15h kube-node-lease k3d-demo-agent-1 k3d-demo-agent-1 4d15h kube-node-lease k3d-demo-server-0 k3d-demo-server-0 4d15h kube-system apiserver-tbovar5ze2pqx4h6gvtcm557sm apiserver-tbovar5ze2pqx4h6gvtcm557sm_8167404a-b62f-45fb-81e8-72eddaf1aaf8 4d15h 使用多个命名空间 命名空间是在多个用户之间划分集群资源的一种方法（通过资源配额）。 例如我们可以设置开发、测试、生产等多个命名空间。 不必使用多个命名空间来分隔轻微不同的资源。 例如同一软件的不同版本： 应该使用标签 来区分同一命名空间中的不同资源。 命名空间适用于跨多个团队或项目的场景。 对于只有几到几十个用户的集群，可以不用创建命名空间。 命名空间不能相互嵌套，每个 Kubernetes 资源只能在一个命名空间中。 管理命名空间 #创建命名空间 $ kubectl create ns develop namespace/develop created #在命名空间内运行Pod --namespace 等价于 -n # kubectl run my-nginx --image=nginx -n=dev $ kubectl run nginx --image=nginx:1.22 --namespace=develop pod/nginx created #查看命名空间内的Pod $ kubectl get pod -n=develop NAME READY STATUS RESTARTS AGE nginx 1/1 Running 0 37s # 默认是 default 下的命名空间 $ kubectl get pod NAME READY STATUS RESTARTS AGE nginx-deploy-5964889c54-fkd8t 1/1 Running 0 161m nginx-deploy-5964889c54-lnd79 1/1 Running 0 161m nginx-deploy-5964889c54-tfdf7 1/1 Running 0 161m 切换当前命名空间 $ kubectl config set-context $(kubectl config current-context) --namespace=develop # 默认命名空间就改变为 develop 了 $ kubectl get pod NAME READY STATUS RESTARTS AGE nginx 1/1 Running 0 3m25s 删除命名空间 $ kubectl delete ns develop namespace \"develop\" deleted # 因为默认被改为 develop 但现在develop 被删除了 $ kubectl get pod No resources found in develop namespace. # 查看ns状态 $ kubectl get ns NAME STATUS AGE default Active 4d15h kube-system Active 4d15h kube-public Active 4d15h kube-node-lease Active 4d15h # 切换为default $ kubectl config set-context $(kubectl config current-context) --namespace=default $ kubectl get pod NAME READY STATUS RESTARTS AGE nginx-deploy-5964889c54-fkd8t 1/1 Running 0 6h6m nginx-deploy-5964889c54-lnd79 1/1 Running 0 6h6m nginx-deploy-5964889c54-tfdf7 1/1 Running 0 6h6m "},"base/declaration.html":{"url":"base/declaration.html","title":"声明式对象配置","keywords":"","body":"声明式对象配置 云原生的代表技术包括： 容器 服务网格 微服务 不可变基础设施 声明式API 管理对象 命令行指令 例如，使用 kubectl 命令来创建和管理 Kubernetes 对象。 命令行就好比口头传达，简单、快速、高效。 但它功能有限，不适合复杂场景，操作不容易追溯，多用于开发和调试。 声明式配置 kubernetes 使用 yaml 文件来描述 Kubernetes 对象。 声明式配置就好比申请表，学习难度大且配置麻烦。 好处是操作留痕，适合操作复杂的对象，多用于生产。 常用命令缩写 名称 缩写 Kind namespaces ns Namespace nodes no Node pods po Pod services srv Service deployments deploy Deployment replicasets rs ReplicaSet statefulsets sts StatefulSet YAML 规范 缩进代表上下级关系 $\\color{red} {缩进时不允许使用 Tab 键，只允许使用空格，通常缩进 2 个空格}$ : 键值对，后面必须有空格 -列表，后面必须有空格 [ ]数组 注释 | 多行文本块 ---表示文档的开始，多用于分割多个资源对象 group: s: 1 name: group-1 members: - name: \"Jack Ma\" UID: 10001 - name: \"Lei Jun\" UID: 10002 # comments words: [\"I don't care money\", \"R U OK\"] text: | line new line 3rd line # --- 多个资源对象的分隔 --- group: name: group-2 members: - name: \"Jack Ma\" UID: 10001 - name: \"Lei Jun\" UID: 10002 # comments words: [\"I don't care money\", \"R U OK\"] text: | line new line 3rd line 配置对象 在创建的 Kubernetes 对象所对应的 yaml 文件中，需要配置的字段如下： apiVersion - Kubernetes API 的版本 kind - 对象类别，例如 Pod、Deployment、Service、ReplicaSet 等 metadata - 描述对象的元数据，包括一个 name 字符串、UID 和可选的 namespace spec - 对象的配置 掌握程度： 不要求自己会写 找模版 能看懂 会修改 能排错 使用 yaml 定义一个Pod Pod 配置模版 apiVersion: v1 kind: Pod metadata: name: nginx spec: containers: - name: nginx image: nginx:1.22 ports: - containerPort: 80 # 执行 $ kubectl apply -f my-pod.yaml pod/nginx created # 查看 nginx 创建了 $ kubectl get pod NAME READY STATUS RESTARTS AGE nginx-deploy-5964889c54-fkd8t 1/1 Running 0 6h7m nginx-deploy-5964889c54-lnd79 1/1 Running 0 6h7m nginx-deploy-5964889c54-tfdf7 1/1 Running 0 6h7m nginx 1/1 Running 0 16s # 删除 $ kubectl delete -f my-pod.yaml pod \"nginx\" deleted 标签 标签（Labels） 是附加到对象（比如 Pod）上的键值对，用于补充对象的描述信息。 标签使用户能够以松散的方式管理对象映射，而无需客户端存储这些映射。 由于一个集群中可能管理成千上万个容器，我们可以使用标签高效的进行选择和操作容器集合。 键的格式： $\\color{red}{前缀}$(可选)/$\\color{red}{名称}$(必须)。 有效名称和值： 必须为 63 个字符或更少（可以为空） 如果不为空，必须以字母数字字符（[a-z0-9A-Z]）开头和结尾 包含破折号-、下划线_、点.和字母或数字 label 配置模版 apiVersion: v1 kind: Pod metadata: name: label-demo labels: environment: production app: nginx spec: containers: - name: nginx image: nginx:1.22 ports: - containerPort: 80 $ kubectl apply -f label-pod.yaml pod/label-demo created $ kubectl get pod NAME READY STATUS RESTARTS AGE nginx-deploy-5964889c54-fkd8t 1/1 Running 0 6h14m nginx-deploy-5964889c54-lnd79 1/1 Running 0 6h14m nginx-deploy-5964889c54-tfdf7 1/1 Running 0 6h14m label-demo 1/1 Running 0 5s # 显示标签 $ kubectl get pod --show-labels NAME READY STATUS RESTARTS AGE LABELS nginx-deploy-5964889c54-fkd8t 1/1 Running 0 6h14m app=nginx-deploy,pod-template-hash=5964889c54 nginx-deploy-5964889c54-lnd79 1/1 Running 0 6h14m app=nginx-deploy,pod-template-hash=5964889c54 nginx-deploy-5964889c54-tfdf7 1/1 Running 0 6h14m app=nginx-deploy,pod-template-hash=5964889c54 label-demo 1/1 Running 0 11s app=nginx,environment=production # -l 过滤 $ kubectl get pod -l \"app=nginx\" NAME READY STATUS RESTARTS AGE label-demo 1/1 Running 0 39s # , 分隔多个条件 $ kubectl get pod -l \"app=nginx,environment=production\" NAME READY STATUS RESTARTS AGE label-demo 1/1 Running 0 57s 选择器 标签选择器 可以识别一组对象。标签不支持唯一性。 标签选择器最常见的用法是为 Service 选择一组 Pod 作为后端。 Service 配置模版 apiVersion: v1 kind: Service metadata: name: my-service spec: type: NodePort selector: app: nginx ports: # 默认情况下，为了方便起见，`targetPort` 被设置为与 `port` 字段相同的值。 - port: 80 targetPort: 80 # 可选字段 # 默认情况下，为了方便起见，Kubernetes 控制平面会从某个范围内分配一个端口号 #（默认：30000-32767） nodePort: 30007 kubectl apply -f my-service.yaml service/my-service created $ kubectl get service NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE kubernetes ClusterIP 10.43.0.1 443/TCP 4d18h nginx-service ClusterIP 10.43.146.225 8080/TCP 6h9m nginx-outside NodePort 10.43.4.121 8081:32555/TCP 5h50m my-service NodePort 10.43.134.176 80:30007/TCP 4s $ kubectl describe svc/my-service Name: my-service Namespace: default Labels: Annotations: Selector: app=nginx Type: NodePort IP Family Policy: SingleStack IP Families: IPv4 IP: 10.43.134.176 IPs: 10.43.134.176 Port: 80/TCP TargetPort: 80/TCP NodePort: 30007/TCP Endpoints: 10.42.1.13:80 Session Affinity: None External Traffic Policy: Cluster Events: # 查看pod 是否被service 选中, 可以看到 Endpoints 对上 $ kubectl get pod -l \"app=nginx\" -owide NAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODE READINESS GATES label-demo 1/1 Running 0 10m 10.42.1.13 k3d-demo-agent-1 目前支持两种类型的选择运算：基于等值的和基于集合的。 多个选择条件使用逗号分隔，相当于 And(&&)运算。 等值选择 selector: matchLabels: # component=redis && version=7.0 component: redis version: 7.0 集合选择 selector: matchExpressions: # tier in (cache, backend) && environment not in (dev, prod) - { key: tier, operator: In, values: [cache, backend] } - { key: environment, operator: NotIn, values: [dev, prod] } 参考资料：https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/kubernetes-objects/ https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/object-management/ https://kubernetes.io/docs/reference/kubectl/#resource-types https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/ https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/labels/ "}}